

객체 : [클래스] 설계도 기반으로 생성된 메모리 공간
변수 : [자료형] 하나의 값을 저장할수 있는 메모리 공간
	배열 : 동일한 자료의 변수를 여러개 선언 [ 저장순서 : 인덱스 ]
		배열명.length : 배열의길이 
		
클래스 : 설계도  
	1. System : 시스템 클래스 
		.out.print()
		.out.println()
		.out.printf()
		
	2. Scanner : 입력 클래스 
		Scanner 입력객체 = new Scanner(System.in)
			입력객체.next 
			입력객체.nextLine
			입력객체.nextInt
			
	3. String : 문자열 클래스 
		.equals( 비교문자 ) : 문자 비교 => 동일하면 true 동일하지 않으면 false
	
		1. String 생성자 : byte열을 문자열 변환
		2. charAt() : 문자 추출
		3. equals(비교대상문자열) :문자열 비교
		4. getBytes() : 문자열을 바이트열로 변환
		5. indexOf() : 문자열 찾기 [ 인수 : 찾을문자열 반환: 찾은 인덱스 위치 ]
		6. contains() : 문자열 포함여부 [ 인수 : 찾을문자열  반환 : true / false ] 
		7. length() : 문자열의 길이
		8. replace() : 문자열 대치
		9. substring() : 문자열 잘라내기
		10. split(분리기준) : 문자열 분리
		11. toLowerCase() : 소문자로 변환    // toUpperCase() : 대문자로 변환
		12. trim() : 문자열 앞뒤 공백 제거 [ 사이공백제거 불가 ]
		13. valueOf() : 기본타입을 문자열 변환
		
	4. Random : 난수 클래스 
		.nextInt(숫자) : 0~숫자 전까지의 난수 생성 
		.nextInt(숫자)+1 : 1~숫자 까지의 난수 생성 
		
	5. Arrays : 배열관련 메소드 제공 클래스
		1. Arrays.copyOf( 복사할배열 , 복사길이 ) : 배열 복사
		2. Arrays.toString(배열) : 인덱스 순으로 데이터 출력
		3. Arrays.copyOfRange(복사할배열 , 시작인덱스 , 끝인덱스)
		4. System.arraycopy( 원본배열, 시작인덱스, 타겟배열 , 타겟시작인덱스 , 복사개수 )
		5. Arrays.equals( 배열1 , 배열2 ) : 1차원 배열 비교
		6. Arrays.deepEquals( 배열1 , 배열2 ) : 2차원 배열 비교
		7. Arrays.sort( 배열명 ) : 해당 배열내 오름차순 정렬
		8. Arrays.sort( 배열명 , Collections.reverseOrder() );  배열내 내림차순 정렬
			" 주의 : 해당 배열이 기본자료형일 경우 불가
		9. Arrays.binarySearch( 배열명 , 데이터 ) : 해당 데이터의 인덱스 번호
			" 주의 : 오름차순 정렬후 사용
		.sort( 배열명 ) : 해당 배열을 오름차순 
		.sort( 배열명, Collections.reverseOrder() ) : 내림차순 
		
	6. Date
		Date 객체명 = new Date() : 현재 시스템내 날짜/시간 객체 
		
		*SimpleDateFormat : 날짜 형식 클래스 
			SimpleDateFormat dateFormat = new SimpleDateFormat( "MM-dd" );
			dateFormat.format(날짜객체);
			
	7. Calendar 클래스
		Calendar now = Calendar.getInstance();
		now.get(Calendar.필드명) : 해당 필드 정보 얻기
		
	7-1. ZonedDateTime 클래스 : 협정시계
		ZonedDateTime.now(ZoneID.of(대륙명/도시명));	
		
	8. Integer : 정수 클래스 
		Integer.parseInt("문자열")   : String -> int형
		Integer.toString(정수) 		: int -> String  
			* 숫자+"" 				: int+"" -> String
		
	9. Math : 수학 클래스
		1. Math.abs()
		2. Math.ceil()
		3. Math.floor()
		4. Math.max()
		5. Math.min()
		6. Math.random() : 0~1 사이의 난수 생성
		7. Math.rint()
		8. Math.round() : 반올림
		
형식문자 [ printf ]  
	%d : 정수 	%숫자d [ 숫자만큼 자릿수 포함 ]		%2d [ 정수가 2칸 차지 ] %02d [ 공백을 0으로사용 ]
	%f : 실수 	%.2f [ 소수점 2자리 표현 ]
	%c : 문자 
	%s : 문자열 
	
제어문자 
	\n : 줄바꿈 
	\t : 들여쓰기 [ 5칸 ]
	\r : 앞칸으로 이동  
	
자료형 
	boolean : 논리 1비트
	char : 문자 2바이트 [유니코드]
	byte : 정수 1바이트 
	short : 정수 2바이트 
	int : 정수 4바이트 [ 기본 정수 자료형 ] 
	long : 정수 8바이트 
	float : 실수 4바이트 [ 소수점 8자리 표현 ] 
	double : 실수 8바이트 [ 소수점 18자리 표현 / 기본 실수 자료형 ] 

산술연산자 : + - * / %
비교연산자 : >= <= > < = !=
논리연산자 : && || !
대입연산자 : = += *= /= %=
증감연산자 : ++ -- 
조건연산자 : 조건식 ? 참 : 거짓 

	제어문 : if , switch
		// if( 조건 ) { 실행문 }
		// else if( 조건2 ) { 실행문 } 
		// else if( 조건3 ) { 실행문 }
		// else { 실행문 }
		
	반복문 : for , while 
		// for( 초기값 ; 조건문 ; 증감식 ) {  실행문 } 
		// [무한루프] while(true){ 실행문 }
			// break; 가장 가까운 반복문 { } 탈출 
			// continue; 가장 가까운 반복문으로 이동 
			
	메모리 : 메모리할당시 주소값[16진수] 부여 [ 바이트당 주소1개 ]
			// 첫번째 주소가 대표 = 배열명, 변수명
			1. 사람 : 변수명 , 자료형 , 값 
			2. 컴퓨터 : 주소값 , 값
	
클래스 
	static : 프로그램 전반적으로 걸쳐 사용되는 메모리에 사용 
	final : 	
	
함수/메소드 : 함[상자] 수[숫자]
		상자안에 들어있는 수 
		미리 정의 해둔 수 
		미리 정의된 코드 
		* [ 미리 정의 => 반복적인 코드 ] 
	1. 미리 정의 된 코드를 반복 호출 
	2. 입력[인수,매개변수] / 출력[반환,리턴]
		* 필수X : 인수O출력X
			인수X출력O
			인수X출력X
			인수O출력O
		* 입력에 따른 서로 다른 결과물 출력 
	3. 메모리 효율 : 
		함수가 실행되면서 메모리할당 
		함수는 종료되면서 메모리초기화 => return[ 반환 ]

	동일한 [내부]클래스내에서 메소드 호출 가능 
	서로다른 [외부]클래스에서 메소드 호출시 객체를 통한 메소드 호출 

오버로딩: 동일한 이름 사용시
	*변수
	
상속 : 설계도 연장
	* 프로젝트마다 클래스 설계 ??? 시간부족
	* 상속 : 미리 만들어진 클래스로부터 설계도 
			제공받아 이어서 새로운 클래스 설계
	
	부모클래스[슈퍼클래스]
	자식클래스[서브클래스]
	
	extends = 상속 키워드 [연장하다 라는뜻]
	
	다중불가 
	
	핸드폰 설계
		전화 문자 기능 
	
	스마트폰 설계
		전화 문자 인터넷 기능 
		
	오버라이딩 : 부모클래스내 메소드 재정의!!
		[ 선언부는 동일하게 ] 
		
	[동일한 {} 안에서]
	필드 , 메소드 : 동일한 이름을 가질수 없다
	
	* 오버라이딩 : 동일한 이름을 가진 메소드를 재정의
	* 오버로딩 : 동일한 생성자의 이름을 가진 생성자 구분(
	
	변수란 자료를 저장하는 상자
	사용목적 데이터를 저장하고 사용하기위해
	기본자료형 논리형 boolean
			문자형 char
			정수 byte short int long 기본형 int
			실수형 float double 기본형 double
	예시 int a = 1;
	
배열이란 변수를 효율적으로 관리할수있게 한다 
	사용목적 : 동일한 타입의 데이터를 순차적으로 저장 하기위해 사용
	 int[] a = new int[10] 10은 배열의 크기 
	 
클래스란 패키지에 소속된 파일 또는 설계도 작성된 코드들의 집합
	사용목적 : 코드를 설계하고 설계되놐드를 실행시키거나 자료로 사용
	예시 public class ~ 
	
객체란 현실에 존재하거나 추상적으로 떠올릴수 있고 자신의 속성을 가지고 있고 다른것과 식별가능한것
	사용목적 
	
생성자란 
	사용목적 객체를 초기화 하기위해 사용
	예시 

메소드란 어떠한문제를 처리하기 위한 방법을 소스 코드로 묶어놓고 필요에따라 동작하는 것
	사용목적 : 객체간의 데이터 전달 수단 
	예시 : 리턴타입 메소드이름 ([매개변수선언]) { 실행문 }
	
	
키워드 : 자바에 등록되어있어서 의미가 약속되어있는 단어
	static : 고정된이란의미를 가지고 있다 
	이키워드를 사용하여 static 변수와 메소드를 만둘스 있고 
	이둘을 합쳐 정적멤버라고한다 
	static은 클래스에 고정되어있으며, 클래스별로 관리된다.
	
		사용목적 : 클래스 객체 생성자 메소드 코드와 공유가능한  키워드
	final 
		사용목적 : 값을 변하지 않게 만드려고 고정값을 만들때 사용한다.	
		
		
접근 제한자 : 
public : 모든 곳에서 호출 가능
	private :  현재 클래스 내애서만 호출 가능
	protected : 동일한 패키지내에서만 호출 가능
		// 상속 있을경우 다른패키지 호출 가능[부모가 다른패키지에 있을경우 부모패키지에 접근 가능]
			// default[생략] : 동일한 패키지내에서만 호출 가능
			
목적 : 모든형태를 코드화 [ 자동화 , 로봇 , AI , 요리 등 ]
객체지향 프로그래밍
		속성 : 필드
		행동 : 메소드[함수]
		
		부모클래스 = 자식클래스[o] : 자동형변환
		자식클래스 = 부모클래스[x] : 강제타입변환
		byte 변수1;
		int 변수2 = 변수1
		byte 변수3 = (byte)변수2
		
스레드 : 코드를 순차적으로 실행		
멀티스레드[ 병렬 작업 ]
	1. 단일 스레드 : main스레드만 있을경우
	2. 멀티 스레드 : 1.Runnable 2. Thread 상속
		* run 메소드를 오버라이딩
		* start메소드를 통한 run 메소드 호출
	3. 동기화 : 여러 스레드가 동일한 메소드에 접근할때 대기순서 매기기
		* synchronized
	4. 스레드 메소드
		1. Thread.sleep() : 일시정지
		2. Thread.yield() : 스레드 양보
		3. Thread.join() : 스레드객체가 끝날때까지 현 스레드 대기
		4. Thread.stop() : 스레드 강제종료 [ 권장 안함]
			*강제종료시 안정성 보장X => stop 메소드 구현
		
(){}[]
() : 인수
생성자() 메소드() 
[] : 배열
int[] 배열 = new
{} : 반복문,제어문,메소드
		
		